from browser import document, html, timer

CELL_SIZE = 40
WALL_THICKNESS = 6
# åœ–ç‰‡è·¯å¾‘
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"

class World:
    """
    å»ºç«‹ Reeborg æ©Ÿå™¨äººä¸–ç•Œï¼ŒåŒ…å«ç¶²æ ¼ã€ç‰†å£å’Œåœ–å±¤ç®¡ç†ã€‚
    """
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.layers = self._create_layers()
        self._init_html()
        self._draw_grid()
        self._draw_walls()
        
    def _create_layers(self):
        # å»ºç«‹å››å€‹ç¨ç«‹çš„ Canvas åœ–å±¤ï¼Œç”¨æ–¼ç¹ªè£½ä¸åŒå…ƒç´  (ç¶²æ ¼ã€ç‰†å£ã€ç—•è·¡ã€æ©Ÿå™¨äºº)
        world_px_width = self.width * CELL_SIZE
        world_px_height = self.height * CELL_SIZE
        return {
            "grid": html.CANVAS(width=world_px_width, height=world_px_height),
            "walls": html.CANVAS(width=world_px_width, height=world_px_height),
            "objects": html.CANVAS(width=world_px_width, height=world_px_height), # ç”¨æ–¼ç¹ªè£½è·¯å¾‘ç—•è·¡
            "robots": html.CANVAS(width=world_px_width, height=world_px_height),
        }

    def _init_html(self):
        # å°‡æ‰€æœ‰åœ–å±¤æ”¾å…¥ä¸€å€‹ç›¸å°å®šä½çš„ DIV å®¹å™¨ä¸­
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px"
        })
        for z, canvas in enumerate(self.layers.values()):
            # æ¯å€‹ Canvas çµ•å°å®šä½ä¸¦å †ç–Šï¼Œz-index ç¢ºä¿æ­£ç¢ºçš„ç¹ªè£½é †åº
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas
        # æ¸…ç©ºä¸¦å°‡ä¸–ç•Œå®¹å™¨æ·»åŠ åˆ°æŒ‡å®šçš„ DOM å…ƒç´ ä¸­
        document["brython_div1"].clear()
        document["brython_div1"] <= container
        
    def _draw_grid(self):
        # ç¹ªè£½ç¶²æ ¼ç·š
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        # è¼‰å…¥ä¸¦ç¹ªè£½åœ–ç‰‡åˆ° Canvas ä¸Š
        img = html.IMG()
        img.src = src
        def onload(evt):
            # åº§æ¨™è½‰æ›ï¼šä¸–ç•Œçš„ (x, y) è½‰ç‚º Canvas çš„åƒç´ åº§æ¨™ (px, py)ã€‚
            # æ³¨æ„ï¼šCanvas çš„ y è»¸å‘ä¸‹ï¼ŒReeborg ä¸–ç•Œçš„ y è»¸å‘ä¸Šã€‚
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)
        
    def _draw_walls(self):
        # ç¹ªè£½ä¸–ç•Œé‚Šç•Œç‰†å£
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            # åŒ—ç‰† (æœ€ä¸Šæ–¹ä¸€åˆ—æ ¼å­çš„ä¸Šé‚Šç·£)
            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1,
                             CELL_SIZE, WALL_THICKNESS, offset_y=0)
            # å—ç‰† (æœ€ä¸‹æ–¹ä¸€åˆ—æ ¼å­çš„ä¸‹é‚Šç·£)
            self._draw_image(ctx, IMG_PATH + "north.png", x, 0,
                             CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)
        for y in range(self.height):
            # è¥¿ç‰† (æœ€å·¦é‚Šä¸€åˆ—æ ¼å­çš„å·¦é‚Šç·£)
            self._draw_image(ctx, IMG_PATH + "east.png", 0, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=0)
            # æ±ç‰† (æœ€å³é‚Šä¸€åˆ—æ ¼å­çš„å³é‚Šç·£)
            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y,
                             WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

    def robot(self, x, y):
        # åœ¨åˆå§‹ä½ç½®ç¹ªè£½æ©Ÿå™¨äºº (éå‹•ç•«ç‰ˆæœ¬ï¼Œä¸»è¦ç”¨æ–¼åˆå§‹åŒ–è¦–è¦ºæ•ˆæœ)
        ctx = self.layers["robots"].getContext("2d")
        # åº§æ¨™è½‰æ›ï¼š(1, 1) è½‰ç‚ºå…§éƒ¨ (0, 0)
        self._draw_image(ctx, IMG_PATH + "blue_robot_e.png", x - 1, y - 1,
                         CELL_SIZE, CELL_SIZE)

class AnimatedRobot:
    """
    å¯æ¥å—æŒ‡ä»¤ä½‡åˆ—ä¸¦åŸ·è¡Œå‹•ç•«çš„æ©Ÿå™¨äººã€‚
    """
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1 # å…§éƒ¨åº§æ¨™ (0-based)
        self.y = y - 1 # å…§éƒ¨åº§æ¨™ (0-based)
        self.facing = "E"
        self.facing_order = ["E", "N", "W", "S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = [] # å„²å­˜å¾…åŸ·è¡Œå‹•ä½œçš„ä½‡åˆ—
        self.running = False # æ¨™è¨˜æ˜¯å¦æ­£åœ¨åŸ·è¡Œå‹•ä½œ
        self._draw_robot()

    def _robot_image(self):
        # æ ¹æ“šæœå‘å›å‚³å°æ‡‰çš„åœ–ç‰‡æª”å
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self):
        # æ¸…ç©ºæ©Ÿå™¨äººåœ–å±¤ï¼Œä¸¦åœ¨æ–°çš„ä½ç½®ç¹ªè£½æ©Ÿå™¨äºº
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(),
                               self.x, self.y, CELL_SIZE, CELL_SIZE)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        # åœ¨ objects åœ–å±¤ç¹ªè£½ç§»å‹•ç—•è·¡
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"
        ctx.lineWidth = 2
        ctx.beginPath()
        
        # å°‡æ©Ÿå™¨äººä¸–ç•Œçš„ä¸­å¿ƒé» (from_x, from_y) è½‰ç‚º Canvas åƒç´ åº§æ¨™
        # fx å’Œ fy æ˜¯èµ·å§‹é»çš„åƒç´ ä¸­å¿ƒåº§æ¨™
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        # tx å’Œ ty æ˜¯çµæŸé»çš„åƒç´ ä¸­å¿ƒåº§æ¨™
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        # å°‡ç§»å‹•å‹•ä½œæ·»åŠ åˆ°ä½‡åˆ—ä¸­
        def action(next_done):
            def step():
                nonlocal steps
                if steps <= 0:
                    next_done() # ç§»å‹•å®Œæˆï¼ŒåŸ·è¡Œä¸‹ä¸€å€‹ä½‡åˆ—å‹•ä½œ
                    return
                
                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                
                # æ ¹æ“šæœå‘è¨ˆç®—ä½ç§»
                if self.facing == "E":
                    dx = 1
                elif self.facing == "W":
                    dx = -1
                elif self.facing == "N":
                    dy = 1
                elif self.facing == "S":
                    dy = -1
                
                next_x = self.x + dx
                next_y = self.y + dy
            
                # é‚Šç•Œæª¢æŸ¥ï¼šæª¢æŸ¥ä¸‹ä¸€æ­¥æ˜¯å¦ä»åœ¨ä¸–ç•Œç¯„åœå…§ (0 åˆ° width/height - 1)
                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, 100) # å»¶é² 100 æ¯«ç§’åŸ·è¡Œä¸‹ä¸€æ­¥å‹•ç•«
                else:
                    print(f"ğŸš¨ æ’åˆ°é‚Šç•Œäº†ï¼åœæ­¢åœ¨ ({from_x + 1}, {from_y + 1})")
                    next_done() # æ’ç‰†ï¼Œç«‹å³åœæ­¢ç§»å‹•ä¸¦åŸ·è¡Œä¸‹ä¸€å€‹ä½‡åˆ—å‹•ä½œ
                    
            step()
            
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        # å°‡å·¦è½‰å‹•ä½œæ·»åŠ åˆ°ä½‡åˆ—ä¸­
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4] # é †åºï¼šE -> N -> W -> S -> E
            self._draw_robot()
            timer.set_timeout(done, 150) # å»¶é² 150 æ¯«ç§’åŸ·è¡Œä¸‹ä¸€å€‹ä½‡åˆ—å‹•ä½œ
            
        self.queue.append(action)
        self._run_queue()
        
    def _run_queue(self):
        # åŸ·è¡Œä½‡åˆ—ä¸­çš„ä¸‹ä¸€å€‹å‹•ä½œ
        if self.running or not self.queue:
            return
            
        self.running = True
        action = self.queue.pop(0)
        # åŸ·è¡Œå‹•ä½œï¼Œä¸¦å‚³å…¥ä¸€å€‹å›å‘¼å‡½æ•¸ (lambda: self._done())ï¼Œç•¶å‹•ä½œå®Œæˆæ™‚æœƒè¢«å‘¼å«
        action(lambda: self._done())

    def _done(self):
        # å‹•ä½œåŸ·è¡Œå®Œæˆï¼Œæº–å‚™åŸ·è¡Œä¸‹ä¸€å€‹ä½‡åˆ—å‹•ä½œ
        self.running = False
        self._run_queue()

# --- æ©Ÿå™¨äººç¨‹å¼é‚è¼¯ ---
def start_patrol(r, width, height):
    """
    å¯¦ä½œå‚ç›´å·¡é‚ (è›‡å½¢) æ¨¡å¼ï¼Œèµ°éæ‰€æœ‰æ ¼å­ã€‚
    
    é‚è¼¯ï¼š
    1. æ©Ÿå™¨äººå¾ (1, 1) é–‹å§‹ï¼Œå…ˆè½‰å‘åŒ— (N)ã€‚
    2. å¶æ•¸åˆ— (0, 2, ...): N å‘å·¡é‚åˆ°åº• (y=9)ï¼Œç„¶å¾Œ N -> E -> S è½‰å‘æ›åˆ—ã€‚
    3. å¥‡æ•¸åˆ— (1, 3, ...): S å‘å·¡é‚åˆ°åº• (y=0)ï¼Œç„¶å¾Œ S -> E -> N è½‰å‘æ›åˆ—ã€‚
    """
    # å‚ç›´ç§»å‹•çš„æ­¥æ•¸ï¼šå¾ä¸€ç«¯èµ°åˆ°å¦ä¸€ç«¯éœ€è¦ height - 1 æ­¥
    steps_to_cross = height - 1
    # æ°´å¹³ç§»å‹•çš„æ­¥æ•¸ï¼šæ¯æ¬¡æ›åˆ—å‘å³ç§»å‹• 1 æ­¥
    steps_to_advance = 1 

    # åˆå§‹è½‰å‘ï¼šå¾ E -> N (1x turn_left)ï¼Œé–‹å§‹ç¬¬ä¸€åˆ—çš„åŒ—å‘å·¡é‚
    r.turn_left()

    # è¿´åœˆéæ­·æ‰€æœ‰å¯¬åº¦ (10 åˆ—)
    for col in range(width):
        # 1. å‚ç›´ç§»å‹•
        r.move(steps_to_cross)

        # 2. æ›åˆ—å’Œè½‰å‘ (é™¤äº†æœ€å¾Œä¸€åˆ—)
        if col < width - 1:
            if col % 2 == 0:
                # å¶æ•¸åˆ— (Col 0, 2, 4...): å®Œæˆ N å·¡é‚ï¼Œä½æ–¼ä¸Šæ–¹ (x, 9)ï¼Œç•¶å‰ Facing Nã€‚
                
                # Step A: N -> E (è½‰å‘å³é‚Šï¼Œ3x turn_left)
                r.turn_left()
                r.turn_left()
                r.turn_left() 
                
                # Step B: å‘å³ç§»å‹•
                r.move(steps_to_advance)
                
                # Step C: E -> S (è½‰å‘å—æ–¹ï¼Œ3x turn_left, ç›¸ç•¶æ–¼å³è½‰)
                r.turn_left()
                r.turn_left()
                r.turn_left()
                
            else:
                # å¥‡æ•¸åˆ— (Col 1, 3, 5...): å®Œæˆ S å·¡é‚ï¼Œä½æ–¼ä¸‹æ–¹ (x, 0)ï¼Œç•¶å‰ Facing Sã€‚
                
                # Step A: S -> E (è½‰å‘å·¦é‚Šï¼Œ1x turn_left)
                r.turn_left() 
                
                # Step B: å‘å³ç§»å‹•
                r.move(steps_to_advance)
                
                # Step C: E -> N (è½‰å‘å·¦é‚Šï¼Œ1x turn_left)
                r.turn_left()


# --- ä¸–ç•Œåˆå§‹åŒ–èˆ‡ç¨‹å¼åŸ·è¡Œ ---
w = World(10, 10)    # å»ºç«‹ 10x10 çš„ä¸–ç•Œ
# é›–ç„¶ World.robot() å·²ç¶“ç¹ªè£½äº†éœæ…‹æ©Ÿå™¨äººï¼Œä½†æˆ‘å€‘éœ€è¦ä¸€å€‹ AnimatedRobot å¯¦ä¾‹ä¾†ç™¼å‡ºæŒ‡ä»¤
r = AnimatedRobot(w, 1, 1) # åœ¨ (1,1) (å…§éƒ¨ (0, 0)) æ”¾ç½®ä¸€å° AnimatedRobot

# é–‹å§‹åŸ·è¡Œå‚ç›´å·¡é‚
start_patrol(r, w.width, w.height)
